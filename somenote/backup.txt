对于内存数据库的完整备份的思考：
1.表结构体需要加入胀位以及锁变量，系统启动时，先对整个数据库备份一次
2.一个表存放在一个文件里，每个文件按怎样的格式存储?
可以先存入表的模式信息（其中应当包含表的记录个数，记录的大小，关键字）然后再按序存入表中的记录(按先序或中序遍历表，将每个记录写入文件中，每个记录的大小是一样的)在将记录写完后，再写入一个完整标记（表示此文件中存放的是一个完整的数据库表）
3.在对表进行重建的时候，其实就是一个创建表，并且进行插入操作的过程，这些过程是根据文件中的信息进行的。
4.在备份的过程中若一个表正在被进行修改，即锁被其他线程获取了，备份线程该怎么做？
很简单，可以直接跳过，等待下次备份过程开始时再进行备份。
5.还有一个问题，由于在备份的过程中，还会有事务对数据库进行修改，当已经提交事务缓存块达到阈值时，是否要将日志写回硬盘，即是否要让备份与写日志并发？
可以并发，只要保证数据的一致性与完整性即可
6.在将一个表写回到硬盘时，需要对表进行加锁，为了减少加锁时间，可以在加锁阶段，仅仅完成将一个表中的数据按格式拷贝到一块内存区中，然后释放掉对表加的锁，再将存放该表的格式化副本写入到磁盘。


----------------------------------------------------------------------
新的问题：
数据库的备份策略,第一次备份(启动服务时，或者说是安装系统后第一次运行系统)要将所有的数据库备份。在运行的过程中的备份则是在检查点算法开始时进行备份(q1:何时开始检查点算法)，此时只是将被修改的表(表结构的dirty变量是否为1)备份回硬盘，也就是说只有某些数据库的某些表需要备份，那么要如何组织本次备份的表文件与上次备份的表文件呢，以及对于一些不完整的备份又该如何处理呢？
有一个想法，给系统中维护两个备份文件，一个是完整备份文件(必然有一个，当系统第一次启动时，就会产生一个完整备份文件)，在以后的每次检查点算法启动备份时，就只是备份上次备份恢复以来已经被修改了的部分，所以还应该维护一个增量部分。当系统崩溃后，如果增量部分是完整的(即在增量部分备份时系统没有发生崩溃)，就用增量部分的文件覆盖掉完整部分的同名的文件，形成一个新的完整的部分。然后就使用该完整部分对数据酷进行恢复。若增量部分不是完整的(q2:如何确定增量部分是否完整？)，就将增量部分删除，直接用原来的完整部分进行恢复。然后再用log进行进一步的恢复。
针对以上两个问题的想法：
a.何时开始检查点算法：
系统中维护一个变量，记录系统中胀位为1的表的个数dirtytable,每次在日志驱动修改后检查dirtytable/tablecount是否达到了预先设定的阈值，若达到，则检查是否正在进行备份，若没有进行备份，则启动备份。
b.如何确定增量部分是否完整
可以在每次启动备份时向log文件中写入startbackup标记,备份完成后再写入endbackup标记，当进行系统恢复时，先检查log文件，从log文件的后面向前扫描，若先发现endbackup标记，则说明增量部分是完整的。如果先找到startbackup，则说明增量部分不是完整的
这与日志的记录类似，日志的记录是以事务为单位，当开始将一个事物的日志写入到log文件中时先写入startTransaction标记，当一个事务的日志记录到log文件之后，再写入endTransaction标记


---------------------------------------------------------------------------
读日志文件，对数据库进行恢复
对日志文件的读取是从后向前，开始读文件时，先根据文件的大小决定读入多少内容到内存设定一个阈值k，当文件大小小于k时,将整个文件读入内存，然后在内存中完成对startCheckpoint和endCheckpoint的查找。当文件大小大于阈值k时，读入文件的末尾到前k个字节的日志到内存中，然后进行查找。查找成功则返回，若查找不成功，则继续再向前读入k个字节，重复上面的查找过程
查找方法：
在对缓存中的内容进行查找时的目的:判断最后的startcheckpoint与最后的endcheckpoint出现的先后顺序，需要注意startcheckpoint和endcheckpoint可能不在一个buffer中即它们的距离超过了k，若是startcheckpoint......
在调用函数findCheckpoint时会有以下不同的结果
if(两个都找到)
{
	if(startchecknum > endchecknum)
	{
		状态为2
		找下一个startcheckpoint
	}
	else
	{
		返回
	}
}
else if(两个都没有找到)
{
	状态为0
}
else
{
	if(找到了startcheckpoint)
	{
		状态为1
		找下一个endcheckpoint
	}
	else//找到了endcheckpoint
	{
		状态为3
		找下一个startcheckpoint
	}
}
